{"ast":null,"code":"// Constantes para el espaciado y límites del canvas\nconst CANVAS_PADDING = 100; // Espacio mínimo desde los bordes\nconst MIN_DISTANCE = 200; // Distancia mínima entre imágenes\n\n/**\n * Genera una posición aleatoria dentro de los límites del viewport\n * @param {number} width - Ancho de la imagen\n * @param {number} height - Alto de la imagen\n * @param {Array} existingPositions - Array de posiciones ya ocupadas\n * @param {Object} viewport - Dimensiones del viewport {width, height}\n * @returns {Object} - Posición {x, y}\n */\nexport const generateRandomPosition = (width, height, existingPositions = [], viewport) => {\n  const maxAttempts = 50;\n  let attempts = 0;\n  while (attempts < maxAttempts) {\n    // Genera posición aleatoria considerando el padding\n    const position = {\n      x: Math.random() * (viewport.width - width - CANVAS_PADDING * 2) + CANVAS_PADDING,\n      y: Math.random() * (viewport.height - height - CANVAS_PADDING * 2) + CANVAS_PADDING\n    };\n\n    // Si no hay otras imágenes, retorna la posición\n    if (existingPositions.length === 0) {\n      return position;\n    }\n\n    // Verifica si la posición está lo suficientemente lejos de las existentes\n    const isFarEnough = existingPositions.every(existing => {\n      const distance = Math.sqrt(Math.pow(existing.x - position.x, 2) + Math.pow(existing.y - position.y, 2));\n      return distance >= MIN_DISTANCE;\n    });\n    if (isFarEnough) {\n      return position;\n    }\n    attempts++;\n  }\n\n  // Si no se encuentra una posición después de maxAttempts, \n  // retorna una posición con offset respecto a la última\n  const lastPosition = existingPositions[existingPositions.length - 1];\n  return {\n    x: lastPosition.x + MIN_DISTANCE,\n    y: lastPosition.y + MIN_DISTANCE\n  };\n};\n\n/**\n * Inicializa las posiciones para un conjunto de imágenes\n * @param {Array} images - Array de objetos de imagen\n * @param {Object} viewport - Dimensiones del viewport\n * @returns {Array} - Array de imágenes con posiciones\n */\nexport const initializeImagePositions = (images, viewport) => {\n  const positionedImages = [];\n  images.forEach(image => {\n    const existingPositions = positionedImages.map(img => ({\n      x: img.x,\n      y: img.y\n    }));\n    const position = generateRandomPosition(image.width, image.height, existingPositions, viewport);\n    positionedImages.push({\n      ...image,\n      ...position,\n      zIndex: positionedImages.length // Añade z-index inicial\n    });\n  });\n  return positionedImages;\n};","map":{"version":3,"names":["CANVAS_PADDING","MIN_DISTANCE","generateRandomPosition","width","height","existingPositions","viewport","maxAttempts","attempts","position","x","Math","random","y","length","isFarEnough","every","existing","distance","sqrt","pow","lastPosition","initializeImagePositions","images","positionedImages","forEach","image","map","img","push","zIndex"],"sources":["/Users/litl/Dropbox/Jona/litl/proyectos/artwall/src/utils/position.js"],"sourcesContent":["// Constantes para el espaciado y límites del canvas\nconst CANVAS_PADDING = 100; // Espacio mínimo desde los bordes\nconst MIN_DISTANCE = 200;   // Distancia mínima entre imágenes\n\n/**\n * Genera una posición aleatoria dentro de los límites del viewport\n * @param {number} width - Ancho de la imagen\n * @param {number} height - Alto de la imagen\n * @param {Array} existingPositions - Array de posiciones ya ocupadas\n * @param {Object} viewport - Dimensiones del viewport {width, height}\n * @returns {Object} - Posición {x, y}\n */\nexport const generateRandomPosition = (width, height, existingPositions = [], viewport) => {\n  const maxAttempts = 50;\n  let attempts = 0;\n\n  while (attempts < maxAttempts) {\n    // Genera posición aleatoria considerando el padding\n    const position = {\n      x: Math.random() * (viewport.width - width - CANVAS_PADDING * 2) + CANVAS_PADDING,\n      y: Math.random() * (viewport.height - height - CANVAS_PADDING * 2) + CANVAS_PADDING\n    };\n\n    // Si no hay otras imágenes, retorna la posición\n    if (existingPositions.length === 0) {\n      return position;\n    }\n\n    // Verifica si la posición está lo suficientemente lejos de las existentes\n    const isFarEnough = existingPositions.every(existing => {\n      const distance = Math.sqrt(\n        Math.pow(existing.x - position.x, 2) + \n        Math.pow(existing.y - position.y, 2)\n      );\n      return distance >= MIN_DISTANCE;\n    });\n\n    if (isFarEnough) {\n      return position;\n    }\n\n    attempts++;\n  }\n\n  // Si no se encuentra una posición después de maxAttempts, \n  // retorna una posición con offset respecto a la última\n  const lastPosition = existingPositions[existingPositions.length - 1];\n  return {\n    x: lastPosition.x + MIN_DISTANCE,\n    y: lastPosition.y + MIN_DISTANCE\n  };\n};\n\n/**\n * Inicializa las posiciones para un conjunto de imágenes\n * @param {Array} images - Array de objetos de imagen\n * @param {Object} viewport - Dimensiones del viewport\n * @returns {Array} - Array de imágenes con posiciones\n */\nexport const initializeImagePositions = (images, viewport) => {\n  const positionedImages = [];\n\n  images.forEach(image => {\n    const existingPositions = positionedImages.map(img => ({ x: img.x, y: img.y }));\n    const position = generateRandomPosition(\n      image.width,\n      image.height,\n      existingPositions,\n      viewport\n    );\n\n    positionedImages.push({\n      ...image,\n      ...position,\n      zIndex: positionedImages.length // Añade z-index inicial\n    });\n  });\n\n  return positionedImages;\n}; "],"mappings":"AAAA;AACA,MAAMA,cAAc,GAAG,GAAG,CAAC,CAAC;AAC5B,MAAMC,YAAY,GAAG,GAAG,CAAC,CAAG;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,sBAAsB,GAAGA,CAACC,KAAK,EAAEC,MAAM,EAAEC,iBAAiB,GAAG,EAAE,EAAEC,QAAQ,KAAK;EACzF,MAAMC,WAAW,GAAG,EAAE;EACtB,IAAIC,QAAQ,GAAG,CAAC;EAEhB,OAAOA,QAAQ,GAAGD,WAAW,EAAE;IAC7B;IACA,MAAME,QAAQ,GAAG;MACfC,CAAC,EAAEC,IAAI,CAACC,MAAM,CAAC,CAAC,IAAIN,QAAQ,CAACH,KAAK,GAAGA,KAAK,GAAGH,cAAc,GAAG,CAAC,CAAC,GAAGA,cAAc;MACjFa,CAAC,EAAEF,IAAI,CAACC,MAAM,CAAC,CAAC,IAAIN,QAAQ,CAACF,MAAM,GAAGA,MAAM,GAAGJ,cAAc,GAAG,CAAC,CAAC,GAAGA;IACvE,CAAC;;IAED;IACA,IAAIK,iBAAiB,CAACS,MAAM,KAAK,CAAC,EAAE;MAClC,OAAOL,QAAQ;IACjB;;IAEA;IACA,MAAMM,WAAW,GAAGV,iBAAiB,CAACW,KAAK,CAACC,QAAQ,IAAI;MACtD,MAAMC,QAAQ,GAAGP,IAAI,CAACQ,IAAI,CACxBR,IAAI,CAACS,GAAG,CAACH,QAAQ,CAACP,CAAC,GAAGD,QAAQ,CAACC,CAAC,EAAE,CAAC,CAAC,GACpCC,IAAI,CAACS,GAAG,CAACH,QAAQ,CAACJ,CAAC,GAAGJ,QAAQ,CAACI,CAAC,EAAE,CAAC,CACrC,CAAC;MACD,OAAOK,QAAQ,IAAIjB,YAAY;IACjC,CAAC,CAAC;IAEF,IAAIc,WAAW,EAAE;MACf,OAAON,QAAQ;IACjB;IAEAD,QAAQ,EAAE;EACZ;;EAEA;EACA;EACA,MAAMa,YAAY,GAAGhB,iBAAiB,CAACA,iBAAiB,CAACS,MAAM,GAAG,CAAC,CAAC;EACpE,OAAO;IACLJ,CAAC,EAAEW,YAAY,CAACX,CAAC,GAAGT,YAAY;IAChCY,CAAC,EAAEQ,YAAY,CAACR,CAAC,GAAGZ;EACtB,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMqB,wBAAwB,GAAGA,CAACC,MAAM,EAAEjB,QAAQ,KAAK;EAC5D,MAAMkB,gBAAgB,GAAG,EAAE;EAE3BD,MAAM,CAACE,OAAO,CAACC,KAAK,IAAI;IACtB,MAAMrB,iBAAiB,GAAGmB,gBAAgB,CAACG,GAAG,CAACC,GAAG,KAAK;MAAElB,CAAC,EAAEkB,GAAG,CAAClB,CAAC;MAAEG,CAAC,EAAEe,GAAG,CAACf;IAAE,CAAC,CAAC,CAAC;IAC/E,MAAMJ,QAAQ,GAAGP,sBAAsB,CACrCwB,KAAK,CAACvB,KAAK,EACXuB,KAAK,CAACtB,MAAM,EACZC,iBAAiB,EACjBC,QACF,CAAC;IAEDkB,gBAAgB,CAACK,IAAI,CAAC;MACpB,GAAGH,KAAK;MACR,GAAGjB,QAAQ;MACXqB,MAAM,EAAEN,gBAAgB,CAACV,MAAM,CAAC;IAClC,CAAC,CAAC;EACJ,CAAC,CAAC;EAEF,OAAOU,gBAAgB;AACzB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}