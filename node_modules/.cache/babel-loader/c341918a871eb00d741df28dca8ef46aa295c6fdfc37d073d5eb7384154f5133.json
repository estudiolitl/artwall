{"ast":null,"code":"// Constantes para el espaciado y límites del canvas\nconst CANVAS_PADDING = 200; // Aumentado para más espacio desde los bordes\nconst MIN_DISTANCE = 400; // Aumentado para más espacio entre imágenes\nconst CANVAS_WIDTH = 5000; // Canvas virtual más grande\nconst CANVAS_HEIGHT = 5000; // Canvas virtual más grande\n\n/**\n * Genera una posición aleatoria dentro de los límites del canvas virtual\n */\nexport const generateRandomPosition = (width, height, existingPositions = [], viewport) => {\n  const maxAttempts = 50;\n  let attempts = 0;\n  while (attempts < maxAttempts) {\n    // Genera posición aleatoria en un canvas virtual más grande\n    const position = {\n      x: Math.random() * (CANVAS_WIDTH - width - CANVAS_PADDING * 2) + CANVAS_PADDING,\n      y: Math.random() * (CANVAS_HEIGHT - height - CANVAS_PADDING * 2) + CANVAS_PADDING\n    };\n\n    // Si no hay otras imágenes, retorna la posición\n    if (existingPositions.length === 0) {\n      return position;\n    }\n\n    // Verifica si la posición está lo suficientemente lejos de las existentes\n    const isFarEnough = existingPositions.every(existing => {\n      const distance = Math.sqrt(Math.pow(existing.x - position.x, 2) + Math.pow(existing.y - position.y, 2));\n      return distance >= MIN_DISTANCE;\n    });\n    if (isFarEnough) {\n      return position;\n    }\n    attempts++;\n  }\n\n  // Si no se encuentra una posición después de maxAttempts, \n  // retorna una posición con offset respecto a la última\n  const lastPosition = existingPositions[existingPositions.length - 1];\n  return {\n    x: lastPosition.x + MIN_DISTANCE,\n    y: lastPosition.y + MIN_DISTANCE\n  };\n};\n\n/**\n * Inicializa las posiciones para un conjunto de imágenes\n * @param {Array} images - Array de objetos de imagen\n * @param {Object} viewport - Dimensiones del viewport\n * @returns {Array} - Array de imágenes con posiciones\n */\nexport const initializeImagePositions = (images, viewport) => {\n  const positionedImages = [];\n  images.forEach(image => {\n    const existingPositions = positionedImages.map(img => ({\n      x: img.x,\n      y: img.y\n    }));\n    const position = generateRandomPosition(image.width, image.height, existingPositions, viewport);\n    positionedImages.push({\n      ...image,\n      ...position,\n      zIndex: positionedImages.length\n    });\n  });\n  return positionedImages;\n};","map":{"version":3,"names":["CANVAS_PADDING","MIN_DISTANCE","CANVAS_WIDTH","CANVAS_HEIGHT","generateRandomPosition","width","height","existingPositions","viewport","maxAttempts","attempts","position","x","Math","random","y","length","isFarEnough","every","existing","distance","sqrt","pow","lastPosition","initializeImagePositions","images","positionedImages","forEach","image","map","img","push","zIndex"],"sources":["/Users/litl/Dropbox/Jona/litl/proyectos/artwall/src/utils/position.js"],"sourcesContent":["// Constantes para el espaciado y límites del canvas\nconst CANVAS_PADDING = 200; // Aumentado para más espacio desde los bordes\nconst MIN_DISTANCE = 400;   // Aumentado para más espacio entre imágenes\nconst CANVAS_WIDTH = 5000;  // Canvas virtual más grande\nconst CANVAS_HEIGHT = 5000; // Canvas virtual más grande\n\n/**\n * Genera una posición aleatoria dentro de los límites del canvas virtual\n */\nexport const generateRandomPosition = (width, height, existingPositions = [], viewport) => {\n  const maxAttempts = 50;\n  let attempts = 0;\n\n  while (attempts < maxAttempts) {\n    // Genera posición aleatoria en un canvas virtual más grande\n    const position = {\n      x: Math.random() * (CANVAS_WIDTH - width - CANVAS_PADDING * 2) + CANVAS_PADDING,\n      y: Math.random() * (CANVAS_HEIGHT - height - CANVAS_PADDING * 2) + CANVAS_PADDING\n    };\n\n    // Si no hay otras imágenes, retorna la posición\n    if (existingPositions.length === 0) {\n      return position;\n    }\n\n    // Verifica si la posición está lo suficientemente lejos de las existentes\n    const isFarEnough = existingPositions.every(existing => {\n      const distance = Math.sqrt(\n        Math.pow(existing.x - position.x, 2) + \n        Math.pow(existing.y - position.y, 2)\n      );\n      return distance >= MIN_DISTANCE;\n    });\n\n    if (isFarEnough) {\n      return position;\n    }\n\n    attempts++;\n  }\n\n  // Si no se encuentra una posición después de maxAttempts, \n  // retorna una posición con offset respecto a la última\n  const lastPosition = existingPositions[existingPositions.length - 1];\n  return {\n    x: lastPosition.x + MIN_DISTANCE,\n    y: lastPosition.y + MIN_DISTANCE\n  };\n};\n\n/**\n * Inicializa las posiciones para un conjunto de imágenes\n * @param {Array} images - Array de objetos de imagen\n * @param {Object} viewport - Dimensiones del viewport\n * @returns {Array} - Array de imágenes con posiciones\n */\nexport const initializeImagePositions = (images, viewport) => {\n  const positionedImages = [];\n\n  images.forEach(image => {\n    const existingPositions = positionedImages.map(img => ({ x: img.x, y: img.y }));\n    const position = generateRandomPosition(\n      image.width,\n      image.height,\n      existingPositions,\n      viewport\n    );\n\n    positionedImages.push({\n      ...image,\n      ...position,\n      zIndex: positionedImages.length\n    });\n  });\n\n  return positionedImages;\n}; "],"mappings":"AAAA;AACA,MAAMA,cAAc,GAAG,GAAG,CAAC,CAAC;AAC5B,MAAMC,YAAY,GAAG,GAAG,CAAC,CAAG;AAC5B,MAAMC,YAAY,GAAG,IAAI,CAAC,CAAE;AAC5B,MAAMC,aAAa,GAAG,IAAI,CAAC,CAAC;;AAE5B;AACA;AACA;AACA,OAAO,MAAMC,sBAAsB,GAAGA,CAACC,KAAK,EAAEC,MAAM,EAAEC,iBAAiB,GAAG,EAAE,EAAEC,QAAQ,KAAK;EACzF,MAAMC,WAAW,GAAG,EAAE;EACtB,IAAIC,QAAQ,GAAG,CAAC;EAEhB,OAAOA,QAAQ,GAAGD,WAAW,EAAE;IAC7B;IACA,MAAME,QAAQ,GAAG;MACfC,CAAC,EAAEC,IAAI,CAACC,MAAM,CAAC,CAAC,IAAIZ,YAAY,GAAGG,KAAK,GAAGL,cAAc,GAAG,CAAC,CAAC,GAAGA,cAAc;MAC/Ee,CAAC,EAAEF,IAAI,CAACC,MAAM,CAAC,CAAC,IAAIX,aAAa,GAAGG,MAAM,GAAGN,cAAc,GAAG,CAAC,CAAC,GAAGA;IACrE,CAAC;;IAED;IACA,IAAIO,iBAAiB,CAACS,MAAM,KAAK,CAAC,EAAE;MAClC,OAAOL,QAAQ;IACjB;;IAEA;IACA,MAAMM,WAAW,GAAGV,iBAAiB,CAACW,KAAK,CAACC,QAAQ,IAAI;MACtD,MAAMC,QAAQ,GAAGP,IAAI,CAACQ,IAAI,CACxBR,IAAI,CAACS,GAAG,CAACH,QAAQ,CAACP,CAAC,GAAGD,QAAQ,CAACC,CAAC,EAAE,CAAC,CAAC,GACpCC,IAAI,CAACS,GAAG,CAACH,QAAQ,CAACJ,CAAC,GAAGJ,QAAQ,CAACI,CAAC,EAAE,CAAC,CACrC,CAAC;MACD,OAAOK,QAAQ,IAAInB,YAAY;IACjC,CAAC,CAAC;IAEF,IAAIgB,WAAW,EAAE;MACf,OAAON,QAAQ;IACjB;IAEAD,QAAQ,EAAE;EACZ;;EAEA;EACA;EACA,MAAMa,YAAY,GAAGhB,iBAAiB,CAACA,iBAAiB,CAACS,MAAM,GAAG,CAAC,CAAC;EACpE,OAAO;IACLJ,CAAC,EAAEW,YAAY,CAACX,CAAC,GAAGX,YAAY;IAChCc,CAAC,EAAEQ,YAAY,CAACR,CAAC,GAAGd;EACtB,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMuB,wBAAwB,GAAGA,CAACC,MAAM,EAAEjB,QAAQ,KAAK;EAC5D,MAAMkB,gBAAgB,GAAG,EAAE;EAE3BD,MAAM,CAACE,OAAO,CAACC,KAAK,IAAI;IACtB,MAAMrB,iBAAiB,GAAGmB,gBAAgB,CAACG,GAAG,CAACC,GAAG,KAAK;MAAElB,CAAC,EAAEkB,GAAG,CAAClB,CAAC;MAAEG,CAAC,EAAEe,GAAG,CAACf;IAAE,CAAC,CAAC,CAAC;IAC/E,MAAMJ,QAAQ,GAAGP,sBAAsB,CACrCwB,KAAK,CAACvB,KAAK,EACXuB,KAAK,CAACtB,MAAM,EACZC,iBAAiB,EACjBC,QACF,CAAC;IAEDkB,gBAAgB,CAACK,IAAI,CAAC;MACpB,GAAGH,KAAK;MACR,GAAGjB,QAAQ;MACXqB,MAAM,EAAEN,gBAAgB,CAACV;IAC3B,CAAC,CAAC;EACJ,CAAC,CAAC;EAEF,OAAOU,gBAAgB;AACzB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}